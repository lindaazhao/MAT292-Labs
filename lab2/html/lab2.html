
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-09-28"><meta name="DC.source" content="lab2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</h1><!--introduction--><p>This lab will teach you to numerically solve first order ODEs using a built in MATLAB integrator, <tt>ode45</tt>.  <tt>ode45</tt> is a good, general purpose tool for integrating first order equations (and first order systems). It is not always the right algorithm, but it is usually the right algorithm to try first. This lab will also teach you how to manipulate symbolic functions in MATLAB.</p><p>You will learn how to use the <tt>ode45</tt> routine, how to interpolate between points, and how MATLAB handles data structures. You will also learn how to use MATLAB for exact symbolic calculations and write your own Picard approximation code.</p><p>Opening the m-file lab2.m in the MATLAB editor, step through each part using cell mode to see the results. Compare the output with the PDF, which was generated from this m-file.</p><p>There are eight exercises in this lab that are to be handed in at the end of the lab. Write your solutions in the template, including appropriate descriptions in each step. Save the .m file and submit it online using Quercus.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Student Information</a></li><li><a href="#2">Set up an inline function representation of an ODE and solve it</a></li><li><a href="#3">Examining the output</a></li><li><a href="#4">Understanding the components of the solution data structure</a></li><li><a href="#5">Visualizing and comparing the solution</a></li><li><a href="#6">Exercise 1</a></li><li><a href="#7">Computing an approximation at a specific point</a></li><li><a href="#8">Exercise 2</a></li><li><a href="#9">Errors, Step Sizes, and Tolerances</a></li><li><a href="#10">Exercise 3</a></li><li><a href="#11">Exercise 4</a></li><li><a href="#12">Exercise 5</a></li><li><a href="#13">Exercise 6 - When things go wrong</a></li><li><a href="#14">Using symbolic variables to define functions</a></li><li><a href="#17">Exercise 7</a></li><li><a href="#18">Obtaining Picard approximations</a></li><li><a href="#19">Exercise 8</a></li></ul></div><h2 id="1">Student Information</h2><p>Student Name: Linda Zhao</p><p>Student Number: 1008107683</p><h2 id="2">Set up an inline function representation of an ODE and solve it</h2><p>MATLAB has many built in routines for solving differential equations of the form</p><p><tt>y' = f(t,y)</tt></p><p>We will solve them using <tt>ode45</tt>, a high precision integrator. To do this, we will need to construct an inline function representation of <tt>f</tt>, an initial condition, and specify how far we want MATLAB to integrate the problem. Once we have set these, we pass the information to <tt>ode45</tt> to get the solution.</p><p>For a first example, we will solve the initial value problem</p><p><tt>y' = y, y(0) = 1</tt></p><p>which has as its answer <tt>y = e^t</tt>.</p><pre class="codeinput"><span class="comment">% Set up the right hand side of the ODE as an inline function</span>
f = @(t,y) y;

<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = 1;

<span class="comment">% The time we will integrate until</span>
t1 = 2;

soln = ode45(f, [t0, t1], y0);
</pre><h2 id="3">Examining the output</h2><p>When we execute the <tt>ode45</tt>, it returns a data structure, stored in soln. We can see the pieces of the data structure with a display command:</p><pre class="codeinput">disp(soln);
</pre><pre class="codeoutput">     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.2000 0.4000 0.6000 0.8000 1 1.2000 1.4000 1.6000 1.8000 2]
          y: [1 1.2214 1.4918 1.8221 2.2255 2.7183 3.3201 4.0552 4.9530 &#8230; ]
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre><h2 id="4">Understanding the components of the solution data structure</h2><p>The most important elements of the data structure are stored in the <tt>x</tt> and <tt>y</tt> components of the structure; these are vectors. Vectors <tt>x</tt> and <tt>y</tt> contain the points at which the numerical approximation to the initial vlaue problem has been computed. In other words, <tt>y(j)</tt> is the approximate value of the solution at <tt>x(j)</tt>.</p><p><b>NOTE:</b> Even though we may be studying a problem like <tt>u(t)</tt> or <tt>y(t)</tt>, MATLAB will always use <tt>x</tt> for the independent variable and <tt>y</tt> for the dependent variable in the data structure.</p><p>Pieces of the data structure can be accessed using a period, as in C/C++ or Java. See the examples below:</p><pre class="codeinput"><span class="comment">% Display the values of |t| at which |y(t)| is approximated</span>
fprintf(<span class="string">' Vector of t values: '</span>);
disp(soln.x);
<span class="comment">% Display the the corresponding approximatations of |y(t)|</span>
fprintf(<span class="string">' Vector of y values: '</span>);
disp(soln.y);

<span class="comment">% Display the approximation of the solution at the 3rd point:</span>
fprintf(<span class="string">' Third element of the vector of t values: %g\n'</span>,soln.x(3));
fprintf(<span class="string">' Third element of the vector of y values: %g\n'</span>,soln.y(3));
</pre><pre class="codeoutput"> Vector of t values:   Columns 1 through 7

         0    0.2000    0.4000    0.6000    0.8000    1.0000    1.2000

  Columns 8 through 11

    1.4000    1.6000    1.8000    2.0000

 Vector of y values:   Columns 1 through 7

    1.0000    1.2214    1.4918    1.8221    2.2255    2.7183    3.3201

  Columns 8 through 11

    4.0552    4.9530    6.0496    7.3891

 Third element of the vector of t values: 0.4
 Third element of the vector of y values: 1.49182
</pre><h2 id="5">Visualizing and comparing the solution</h2><p>We can now visualize the solution at the computed data points and compare with the exact solution.</p><pre class="codeinput"><span class="comment">% Construct the exact solution</span>
tt = linspace(0,2,50);
yy = exp(tt);

<span class="comment">% Plot both on the same figure, plotting the approximation with x's</span>
plot(tt, yy, soln.x, soln.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
<span class="comment">% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6</span>
<span class="comment">% and 1, respectively.  This makes the print out more readable.</span>

<span class="comment">% Add a label to the axis and a legend</span>
xlabel(<span class="string">'t'</span>);
legend(<span class="string">'Exact'</span>, <span class="string">'Numerical'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
</pre><img vspace="5" hspace="5" src="lab2_01.png" alt=""> <h2 id="6">Exercise 1</h2><p>Objective: Solve an initial value problem and plot both the numerical approximation and the corresponding exact solution.</p><p>Details: Solve the IVP</p><p><tt>y' = y tan t + sin t, y(0) = -1/2</tt></p><p>from <tt>t = 0</tt> to <tt>t = pi</tt>.</p><p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p><p>Your submission should show the construction of the inline function, the use of ode45 to obtain the solution, a construction of the exact solution, and a plot showing both. In the comments, include the exact solution.</p><p>Label your axes and include a legend.</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 1 Submission</span>
<span class="comment">% =========================================================================================</span>

<span class="comment">% Exact solution to the IVP: y(t) = -0.5cos(t), t E (0, pi)</span>

<span class="comment">% Generate the numerical approximation</span>
f1 = @(t,y) y*tan(t) + sin(t);       <span class="comment">% Set up the right hand side of the ODE as an inline function</span>

t0 = 0;                              <span class="comment">% Define initial conditions</span>
y0 = -0.5;

t1 = pi;                             <span class="comment">% Integrate until t = pi</span>

soln1 = ode45(f1, [t0, t1], y0);     <span class="comment">% Compute numerical solution using ode45</span>

<span class="comment">% Construct exact solution</span>
tvals = linspace(0, pi, 100);
yexact1 = -0.5*cos(tvals);

<span class="comment">% Plot both the exact solution and numerical approximation</span>
plot(tvals, yexact1, soln1.x, soln1.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
legend(<span class="string">'Exact'</span>, <span class="string">'Numerical'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);

<span class="comment">% =========================================================================================</span>
</pre><img vspace="5" hspace="5" src="lab2_02.png" alt=""> <h2 id="7">Computing an approximation at a specific point</h2><p>As you should be able to see by examining <tt>soln.x</tt>, ode45 returns the solution at a number of points between <tt>t0</tt> and <tt>t1</tt>. But sometimes we want to know the solution at some intermediate point.</p><p>To obtain this value, we need to interpolate it in a consistent way. Fortunately, MATLAB provides a convenient function, <tt>deval</tt>, specifically for this.</p><pre class="codeinput"><span class="comment">% Compute the solution at t = .25:</span>
deval(soln, .25)

<span class="comment">% Compute the solution at t = 1.6753:</span>
fprintf(<span class="string">' Solution at 1.6753: %g\n'</span>, deval(soln, 1.6753));

<span class="comment">% Compute the solution at 10 grid points between .45 and 1.65:</span>
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

<span class="comment">% Alternatively:</span>
deval(soln, linspace(.45, 1.65, 10))
</pre><pre class="codeoutput">
ans =

    1.2840

 Solution at 1.6753: 5.3404

ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070


ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070

</pre><h2 id="8">Exercise 2</h2><p>Objective: Interpolate a solution at a number of grid points</p><p>Details: For the solution you computed in exercise 1, use deval to compute the interpolated values at 10 grid points between 2 and 3.</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 2 Submission</span>
<span class="comment">% =========================================================================================</span>

tinterp = linspace(2, 3, 10);
ydeval = deval(soln1, tinterp);
plot(tvals, yexact1, tinterp, ydeval, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);

<span class="comment">% =========================================================================================</span>
</pre><img vspace="5" hspace="5" src="lab2_03.png" alt=""> <h2 id="9">Errors, Step Sizes, and Tolerances</h2><p>As you may have noticed, in contrast to the IODE software, at no point do we set a step size for our solution. Indeed, the step size is set adaptively to conform to a specified error tolerance.</p><p>Roughly speaking, given the solution at <tt>(t_j, y_j)</tt>, <tt>ode45</tt> computes two approximations of the solution at <tt>t_{j+1} = t_j + h</tt>; one is of greater accuracy than the other. If the difference is below a specified tolerance, the step is accepted and we continue. Otherwise the step is rejected and the smaller step size, <tt>h</tt>, is used; it is often halved.</p><p>We can compute the global truncation error at each solution point, figure out the maximum error, and visualize this error (on a linear-log scale):</p><pre class="codeinput"><span class="comment">% Compute the exact solution</span>
yexact = exp(soln.x);

<span class="comment">% Compute the pointwise error; note the use of MATLAB's vectorization</span>
err = abs(yexact - soln.y);

disp(err);

fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));

semilogy(soln.x, err, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'error'</span>);
</pre><pre class="codeoutput">   1.0e-06 *

  Columns 1 through 7

         0    0.0152    0.0371    0.0679    0.1106    0.1688    0.2475

  Columns 8 through 11

    0.3526    0.4922    0.6764    0.9179

maximum error: 9.17923e-07 
</pre><img vspace="5" hspace="5" src="lab2_04.png" alt=""> <h2 id="10">Exercise 3</h2><p>Objective: Examine the error of a solution generated by <tt>ode45</tt></p><p>Details: For your solution to exercise 1, compute the pointwise error, identify the maximum value of the error, and visualize the error on a linear-log plot (use semilogy to plot the log of the error vs. t). Write in the comments where the error is largest, and give a brief (1-2 sentences) explanation of why it is largest there. Make sure to label your axes.</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 3 Submission</span>
<span class="comment">% =========================================================================================</span>

<span class="comment">% Exact solution</span>
yexact = -0.5*cos(soln1.x);

<span class="comment">% Compute the pointwise error</span>
err = abs(yexact - soln1.y);

disp(err);

fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));
<span class="comment">% The maximum error occurs at t = 1.5588.</span>
<span class="comment">% The error is likely largest here because t = 1.5588 is very close to pi/2,</span>
<span class="comment">% which is an asymptote where tan(t) tends to infinity. As a result, ode45 has</span>
<span class="comment">% to deal with a value nearing infinity in the ODE dy/dt = y*tan(t) + sin(t),</span>
<span class="comment">% making it difficult to generate an accurate approximation.</span>

semilogy(soln1.x, err, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'error'</span>);

<span class="comment">% =========================================================================================</span>
</pre><pre class="codeoutput">   1.0e-04 *

  Columns 1 through 7

         0    0.0001    0.0006    0.0021    0.0070    0.0077    0.0087

  Columns 8 through 14

    0.0230    0.0408    0.1807    0.0254    0.0114    0.0068    0.0055

  Columns 15 through 17

    0.0047    0.0043    0.0043

maximum error: 1.8068e-05 
</pre><img vspace="5" hspace="5" src="lab2_05.png" alt=""> <h2 id="11">Exercise 4</h2><p>Objective: Solve and visualize a nonlinear ode using ode45</p><p>Details: Solve the IVP</p><p><tt>y' = 1 / y^2 , y(1) = 1</tt></p><p>from <tt>t=1</tt> to <tt>t=10</tt> using <tt>ode45</tt>. Find the exact solution and compute the maximum pointwise error. Then plot the approximate solution and the exact solution on the same axes.</p><p>Your solution should show the definition of the inline function, the computation of its solution in this interval, the computation of the exact solution at the computed grid points, the computation of the maximum error, and a plot of the exact and approximate solutions.</p><p>Your axes should be appropriately labeled and include a legend.</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 4 Submission</span>
<span class="comment">% =========================================================================================</span>

f4 = @(t, y) 1 / y^2;               <span class="comment">% Define inline function</span>

t0 = 1;                             <span class="comment">% Set up initial condition</span>
y0 = 1;

t1 = 10;                            <span class="comment">% Integrate until t = 10</span>

soln4 = ode45(f4, [t0, t1], y0);    <span class="comment">% Compute the numerical solution using ode45</span>
yexact4 = (3*soln4.x - 2).^(1/3);   <span class="comment">% Compute exact solution at same points: y = (3x - 2)^(1/3)</span>

err4 = abs(yexact4 - soln4.y);      <span class="comment">% Compute pointwise error</span>
max_err = max(err4)                 <span class="comment">% Determine (and print) max error</span>

<span class="comment">% Plot exact &amp; approximate solutions, label plot</span>
plot(soln4.x, yexact4, soln4.x, soln4.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2)
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y'</span>)
legend(<span class="string">'Exact Solution'</span>, <span class="string">'Numerical Approximation'</span>, <span class="string">'Location'</span>, <span class="string">'best'</span>)

<span class="comment">% =========================================================================================</span>
</pre><pre class="codeoutput">
max_err =

    0.0017

</pre><img vspace="5" hspace="5" src="lab2_06.png" alt=""> <h2 id="12">Exercise 5</h2><p>Objective: Solve and visualize an ODE that cannot be solved by hand with <tt>ode45</tt>.</p><p>Details: Solve the IVP</p><p><tt>y' = 1 - t y / 2, y(0) = -1</tt></p><p>from <tt>t=0</tt> to <tt>t=10</tt>.</p><p>Your solution should show you defining the inline function, computing the solution in this interval, and plotting it.</p><p>Your axes should be appropriately labeled</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 5 Submission</span>
<span class="comment">% =========================================================================================</span>
f5 = @(t, y) 1 - t*y/2              <span class="comment">% Define inline function</span>

t0 = 0;                             <span class="comment">% Set up initial condition</span>
y0 = -1;

t1 = 10;                            <span class="comment">% Solve until t = 10</span>

soln5 = ode45(f5, [t0, t1], y0);    <span class="comment">% Solve ODE numerically w/ode45</span>

<span class="comment">% Plot numerical solution</span>
plot(soln5.x, soln5.y, <span class="string">'x'</span>, soln5.x, soln5.y, <span class="string">'Color'</span>, <span class="string">'#0072BD'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2)
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y'</span>)
legend(<span class="string">"Numerical Approximation of IVP"</span>)

<span class="comment">% =========================================================================================</span>
</pre><img vspace="5" hspace="5" src="lab2_07.png" alt=""> <h2 id="13">Exercise 6 - When things go wrong</h2><p>Objective: Solve an ode and explain the warning message</p><p>Details: Solve the IVP:</p><p><tt>y' = y^3 - t^2, y(0) = 1</tt></p><p>from <tt>t=0</tt> to <tt>t=1</tt>.</p><p>Your solution should show you defining the inline function, and computing the solution in this interval.</p><p>If you try to plot the solution, you should find that the solution does not make it all the way to t = 1.</p><p>In the comments explain why MATLAB generates the warning message that you may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction field for this with IODE.</p><pre class="codeinput"><span class="comment">% =========================================================================================</span>
<span class="comment">% Exercise 6 Submission</span>
<span class="comment">% =========================================================================================</span>
f6 = @(t, y) y^3 - t^2;                 <span class="comment">% Define inline function</span>

t0 = 0;                                 <span class="comment">% Set up initial conditions</span>
y0 = 1;
t1 = 1;                                 <span class="comment">% Solve until t = 1</span>

soln6 =ode45(f6, [t0, t1], y0);         <span class="comment">% Compute solution using ode45</span>

<span class="comment">% Plot numerical solution</span>
plot(soln6.x, soln6.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2)
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y'</span>)
legend(<span class="string">"Numerical Approximation of IVP"</span>)

<span class="comment">% Warning Message: Warning: Failure at t=5.066046e-01.  Unable to meet integration</span>
<span class="comment">% tolerances without reducing the step size below the smallest value allowed (1.776357e-15) at time t.</span>

<span class="comment">% This warning message likely occurs because the function increases too</span>
<span class="comment">% quickly for its values to be computed accurately. If we look at the</span>
<span class="comment">% direction field for this IVP using IODE, dy/dt approaches infinity very</span>
<span class="comment">% quickly at t ~= 0.5, meaning that taking even very small steps would</span>
<span class="comment">% result in a near infinite change in y.</span>
<span class="comment">% =========================================================================================</span>
<span class="comment">% =========================================================================================</span>
</pre><img vspace="5" hspace="5" src="lab2_08.png" alt=""> <h2 id="14">Using symbolic variables to define functions</h2><p>We can define symbolic variables to let MATLAB know that these variables will be used for exact computations</p><pre class="codeinput"><span class="comment">% Start by defining the variables as symbolic</span>
syms <span class="string">t</span> <span class="string">s</span> <span class="string">x</span> <span class="string">y</span>

<span class="comment">% Define a function by simply writing its expression</span>

f = cos(t)
g = sin(t)
h = exp(2*x)

<span class="comment">% We can manipulate these functions</span>

simplify(f^2+g^2)
diff(h)

<span class="comment">% We can plot a function defined symbolically using the command |ezplot|.</span>
<span class="comment">% Learn about the command |ezplot|:</span>

help <span class="string">ezplot</span>

<span class="comment">% Plot the function |f(t)| and |h(x)|</span>

ezplot(f)
ezplot(h)
</pre><pre class="codeoutput error">Undefined function 'syms' for input arguments of type 'char'.

Error in lab2 (line 376)
syms t s x y
</pre><p>If we try to evaluate the function <tt>f(0)</tt>, we get an error message.</p><p>The symbolic variables are not meant to be used to evaluate functions, but to manipulate functions, compute derivatives, etc. To evaluate a function using symbolic variables is a little cumbersome:</p><pre class="codeinput"><span class="comment">% We need to substitute the variable by a value:</span>

subs(f,t,pi)
</pre><p>This expression means: In the expression <tt>f</tt>, substitute the variable <tt>t</tt> by the number <tt>pi</tt>.</p><pre class="codeinput"><span class="comment">% If we use a value where the cosine does not have a "nice" expression, we</span>
<span class="comment">% need to approximate the result:</span>

subs(f,t,2)

<span class="comment">% We need to use the command |eval|</span>

eval(subs(f,t,2))
</pre><h2 id="17">Exercise 7</h2><p>Objective: Define a function using symbolic variables and manipulate it.</p><p>Details: Define the function <tt>f(x) = sin(x)cos(x)</tt></p><p>Use MATLAB commands to obtain a simpler form of this function, compute value of this function for <tt>x=pi/4</tt> and <tt>x=1</tt>, and plot its graph.</p><h2 id="18">Obtaining Picard approximations</h2><p>Consider an initial value problem</p><p><tt>y' = 1 + y</tt> <tt>y(0) = 0</tt></p><p>First we need to define the variables we will be using</p><pre class="codeinput">syms <span class="string">t</span> <span class="string">s</span> <span class="string">y</span>;

<span class="comment">% We then need to define the function f</span>

f = 1+y; <span class="comment">% we define it without the @(t,y) because it is a symbolic function</span>

<span class="comment">% We set up our initial approximation phi_0 = 0:</span>

phi=[sym(0)];   <span class="comment">% we will keep a list with all the approximations</span>

<span class="comment">% Set up a loop to get successive approximations using Picard iterations</span>

N=5;

<span class="keyword">for</span> i = 1:N
    func=subs(f,y,phi(i));    <span class="comment">% prepare function to integrate: y -&gt; previous phi</span>
    func=subs(func,t,s);      <span class="comment">% variable of integration is s, so we need to change</span>
                              <span class="comment">% t -&gt; s</span>

    newphi = int(func, s, 0 ,t);   <span class="comment">% integrate to find next approximation</span>

    phi=cat(2,phi,[newphi]);       <span class="comment">% update the list of approximations by adding new phi</span>
<span class="keyword">end</span>

<span class="comment">% Show the last approximation</span>

phi(N+1)

<span class="comment">% Plot the approximation just found</span>

picard=ezplot(phi(N+1),[0,5]);
set(picard,<span class="string">'Color'</span>,<span class="string">'green'</span>);         <span class="comment">% set the color of the graph to green</span>

<span class="comment">% In this case, the exact solution is</span>
<span class="comment">%</span>
<span class="comment">% |y=e^t-1|</span>
<span class="comment">%</span>
<span class="comment">% Compare the approximation and the exact solutions</span>

hold <span class="string">on</span>;
exact=ezplot(exp(t)-1,[0,5]);

xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Picard Approximations'</span>);
legend(<span class="string">'Picard Approximation'</span>, <span class="string">'Exact Solution'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
</pre><h2 id="19">Exercise 8</h2><pre>Objective: Solve your own Picard Approximation and compare it to the
exact solution.</pre><pre>Details: Consider the IVP
   | y' = 1+y^2|
   | y(0) = 1 |</pre><p>Find the Picard approximation phi_5. For better efficiency, do not keep all the previous approximations.</p><p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p><p>Label your axes and include a legend.</p><p>HINT. The initial condition has 1 instead of 0, so the Picard method needs to be adapted.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation
% This lab will teach you to numerically solve first order ODEs using a built 
% in MATLAB integrator, |ode45|.  |ode45| is a good, general purpose tool for 
% integrating first order equations (and first order systems). It is not always 
% the right algorithm, but it is usually the right algorithm to try first. This 
% lab will also teach you how to manipulate symbolic functions in MATLAB.
% 
% You will learn how to use the |ode45| routine, how to interpolate between 
% points, and how MATLAB handles data structures. You will also learn how to use 
% MATLAB for exact symbolic calculations and write your own Picard approximation 
% code.
% 
% Opening the m-file lab2.m in the MATLAB editor, step through each part using 
% cell mode to see the results. Compare the output with the PDF, which was generated 
% from this m-file.
% 
% There are eight exercises in this lab that are to be handed in at the end 
% of the lab. Write your solutions in the template, including appropriate descriptions 
% in each step. Save the .m file and submit it online using Quercus.
%% Student Information
% Student Name: Linda Zhao
% 
% Student Number: 1008107683
%% Set up an inline function representation of an ODE and solve it
% MATLAB has many built in routines for solving differential equations of the 
% form
% 
% |y' = f(t,y)|
% 
% We will solve them using |ode45|, a high precision integrator. To do this, 
% we will need to construct an inline function representation of |f|, an initial 
% condition, and specify how far we want MATLAB to integrate the problem. Once 
% we have set these, we pass the information to |ode45| to get the solution.
% 
% For a first example, we will solve the initial value problem
% 
% |y' = y, y(0) = 1|
% 
% which has as its answer |y = e^t|. 

% Set up the right hand side of the ODE as an inline function
f = @(t,y) y; 

% The initial conditions
t0 = 0;
y0 = 1;

% The time we will integrate until
t1 = 2;

soln = ode45(f, [t0, t1], y0);
%% Examining the output
% When we execute the |ode45|, it returns a data structure, stored in soln. 
% We can see the pieces of the data structure with a display command:

disp(soln);
%% Understanding the components of the solution data structure
% The most important elements of the data structure are stored in the |x| and 
% |y| components of the structure; these are vectors. Vectors |x| and |y| contain 
% the points at which the numerical approximation to the initial vlaue problem 
% has been computed. In other words, |y(j)| is the approximate value of the solution 
% at |x(j)|.
% 
% *NOTE:* Even though we may be studying a problem like |u(t)| or |y(t)|, MATLAB 
% will always use |x| for the independent variable and |y| for the dependent variable 
% in the data structure.
% 
% Pieces of the data structure can be accessed using a period, as in C/C++ or 
% Java. See the examples below:

% Display the values of |t| at which |y(t)| is approximated
fprintf(' Vector of t values: ');
disp(soln.x);
% Display the the corresponding approximatations of |y(t)|
fprintf(' Vector of y values: ');
disp(soln.y);

% Display the approximation of the solution at the 3rd point:
fprintf(' Third element of the vector of t values: %g\n',soln.x(3));
fprintf(' Third element of the vector of y values: %g\n',soln.y(3));
%% Visualizing and comparing the solution
% We can now visualize the solution at the computed data points and compare 
% with the exact solution.

% Construct the exact solution
tt = linspace(0,2,50);
yy = exp(tt);

% Plot both on the same figure, plotting the approximation with x's
plot(tt, yy, soln.x, soln.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6
% and 1, respectively.  This makes the print out more readable.

% Add a label to the axis and a legend
xlabel('t');
legend('Exact', 'Numerical','Location','Best');
%% Exercise 1
% Objective: Solve an initial value problem and plot both the numerical approximation 
% and the corresponding exact solution.
% 
% Details: Solve the IVP
% 
% |y' = y tan t + sin t, y(0) = -1/2|
% 
% from |t = 0| to |t = pi|.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.
% 
% Your submission should show the construction of the inline function, the use 
% of ode45 to obtain the solution, a construction of the exact solution, and a 
% plot showing both. In the comments, include the exact solution.
% 
% Label your axes and include a legend.

% =========================================================================================
% Exercise 1 Submission
% =========================================================================================

% Exact solution to the IVP: y(t) = -0.5cos(t), t E (0, pi)

% Generate the numerical approximation
f1 = @(t,y) y*tan(t) + sin(t);       % Set up the right hand side of the ODE as an inline function

t0 = 0;                              % Define initial conditions
y0 = -0.5;

t1 = pi;                             % Integrate until t = pi

soln1 = ode45(f1, [t0, t1], y0);     % Compute numerical solution using ode45

% Construct exact solution
tvals = linspace(0, pi, 100);
yexact1 = -0.5*cos(tvals);

% Plot both the exact solution and numerical approximation
plot(tvals, yexact1, soln1.x, soln1.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
legend('Exact', 'Numerical','Location','Best');
xlabel('t');
ylabel('y');

% =========================================================================================


%% Computing an approximation at a specific point
% As you should be able to see by examining |soln.x|, ode45 returns the solution 
% at a number of points between |t0| and |t1|. But sometimes we want to know the 
% solution at some intermediate point.
% 
% To obtain this value, we need to interpolate it in a consistent way. Fortunately, 
% MATLAB provides a convenient function, |deval|, specifically for this.

% Compute the solution at t = .25:
deval(soln, .25)

% Compute the solution at t = 1.6753:
fprintf(' Solution at 1.6753: %g\n', deval(soln, 1.6753));

% Compute the solution at 10 grid points between .45 and 1.65:
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

% Alternatively:
deval(soln, linspace(.45, 1.65, 10))
%% Exercise 2
% Objective: Interpolate a solution at a number of grid points
% 
% Details: For the solution you computed in exercise 1, use deval to compute 
% the interpolated values at 10 grid points between 2 and 3.

% =========================================================================================
% Exercise 2 Submission
% =========================================================================================

tinterp = linspace(2, 3, 10);
ydeval = deval(soln1, tinterp);
plot(tvals, yexact1, tinterp, ydeval, 'x', 'MarkerSize',10, 'LineWidth', 2);

% =========================================================================================


%% Errors, Step Sizes, and Tolerances
% As you may have noticed, in contrast to the IODE software, at no point do 
% we set a step size for our solution. Indeed, the step size is set adaptively 
% to conform to a specified error tolerance. 
% 
% Roughly speaking, given the solution at |(t_j, y_j)|, |ode45| computes two 
% approximations of the solution at |t_{j+1} = t_j + h|; one is of greater accuracy 
% than the other. If the difference is below a specified tolerance, the step is 
% accepted and we continue. Otherwise the step is rejected and the smaller step 
% size, |h|, is used; it is often halved.
% 
% We can compute the global truncation error at each solution point, figure 
% out the maximum error, and visualize this error (on a linear-log scale):

% Compute the exact solution
yexact = exp(soln.x);

% Compute the pointwise error; note the use of MATLAB's vectorization
err = abs(yexact - soln.y);

disp(err);

fprintf('maximum error: %g \n', max(err));

semilogy(soln.x, err, 'LineWidth', 2);
xlabel('t');
ylabel('error');
%% Exercise 3
% Objective: Examine the error of a solution generated by |ode45|
% 
% Details: For your solution to exercise 1, compute the pointwise error, identify 
% the maximum value of the error, and visualize the error on a linear-log plot 
% (use semilogy to plot the log of the error vs. t). Write in the comments where 
% the error is largest, and give a brief (1-2 sentences) explanation of why it 
% is largest there. Make sure to label your axes.

% =========================================================================================
% Exercise 3 Submission
% =========================================================================================

% Exact solution
yexact = -0.5*cos(soln1.x);

% Compute the pointwise error
err = abs(yexact - soln1.y);

disp(err);

fprintf('maximum error: %g \n', max(err));
% The maximum error occurs at t = 1.5588. 
% The error is likely largest here because t = 1.5588 is very close to pi/2,
% which is an asymptote where tan(t) tends to infinity. As a result, ode45 has 
% to deal with a value nearing infinity in the ODE dy/dt = y*tan(t) + sin(t), 
% making it difficult to generate an accurate approximation.

semilogy(soln1.x, err, 'LineWidth', 2);
xlabel('t');
ylabel('error');

% =========================================================================================


%% Exercise 4
% Objective: Solve and visualize a nonlinear ode using ode45
% 
% Details: Solve the IVP
% 
% |y' = 1 / y^2 , y(1) = 1|
% 
% from |t=1| to |t=10| using |ode45|. Find the exact solution and compute the 
% maximum pointwise error. Then plot the approximate solution and the exact solution 
% on the same axes.
% 
% Your solution should show the definition of the inline function, the computation 
% of its solution in this interval, the computation of the exact solution at the 
% computed grid points, the computation of the maximum error, and a plot of the 
% exact and approximate solutions.
% 
% Your axes should be appropriately labeled and include a legend.

% =========================================================================================
% Exercise 4 Submission
% =========================================================================================

f4 = @(t, y) 1 / y^2;               % Define inline function

t0 = 1;                             % Set up initial condition
y0 = 1;

t1 = 10;                            % Integrate until t = 10

soln4 = ode45(f4, [t0, t1], y0);    % Compute the numerical solution using ode45
yexact4 = (3*soln4.x - 2).^(1/3);   % Compute exact solution at same points: y = (3x - 2)^(1/3)

err4 = abs(yexact4 - soln4.y);      % Compute pointwise error
max_err = max(err4)                 % Determine (and print) max error

% Plot exact & approximate solutions, label plot
plot(soln4.x, yexact4, soln4.x, soln4.y, 'x', 'MarkerSize',10, 'LineWidth', 2)
xlabel('t')
ylabel('y')
legend('Exact Solution', 'Numerical Approximation', 'Location', 'best')

% =========================================================================================


%% Exercise 5
% Objective: Solve and visualize an ODE that cannot be solved by hand with |ode45|.
% 
% Details: Solve the IVP
% 
% |y' = 1 - t y / 2, y(0) = -1|
% 
% from |t=0| to |t=10|. 
% 
% Your solution should show you defining the inline function, computing the 
% solution in this interval, and plotting it.
% 
% Your axes should be appropriately labeled

% =========================================================================================
% Exercise 5 Submission
% =========================================================================================
f5 = @(t, y) 1 - t*y/2              % Define inline function

t0 = 0;                             % Set up initial condition
y0 = -1;

t1 = 10;                            % Solve until t = 10

soln5 = ode45(f5, [t0, t1], y0);    % Solve ODE numerically w/ode45

% Plot numerical solution
plot(soln5.x, soln5.y, 'x', soln5.x, soln5.y, 'Color', '#0072BD', 'MarkerSize',10, 'LineWidth', 2)
xlabel('t')
ylabel('y')
legend("Numerical Approximation of IVP")

% =========================================================================================


%% Exercise 6 - When things go wrong
% Objective: Solve an ode and explain the warning message
% 
% Details: Solve the IVP:
% 
% |y' = y^3 - t^2, y(0) = 1|
% 
% from |t=0| to |t=1|. 
% 
% Your solution should show you defining the inline function, and computing 
% the solution in this interval.
% 
% If you try to plot the solution, you should find that the solution does not 
% make it all the way to t = 1.
% 
% In the comments explain why MATLAB generates the warning message that you 
% may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction 
% field for this with IODE.

% =========================================================================================
% Exercise 6 Submission
% =========================================================================================
f6 = @(t, y) y^3 - t^2;                 % Define inline function

t0 = 0;                                 % Set up initial conditions
y0 = 1;
t1 = 1;                                 % Solve until t = 1

soln6 =ode45(f6, [t0, t1], y0);         % Compute solution using ode45

% Plot numerical solution
plot(soln6.x, soln6.y, 'x', 'MarkerSize',10, 'LineWidth', 2)
xlabel('t')
ylabel('y')
legend("Numerical Approximation of IVP")

% Warning Message: Warning: Failure at t=5.066046e-01.  Unable to meet integration 
% tolerances without reducing the step size below the smallest value allowed (1.776357e-15) at time t.

% This warning message likely occurs because the function increases too
% quickly for its values to be computed accurately. If we look at the
% direction field for this IVP using IODE, dy/dt approaches infinity very
% quickly at t ~= 0.5, meaning that taking even very small steps would
% result in a near infinite change in y.
% =========================================================================================
% =========================================================================================


%% Using symbolic variables to define functions
% We can define symbolic variables to let MATLAB know that these variables will 
% be used for exact computations

% Start by defining the variables as symbolic
syms t s x y

% Define a function by simply writing its expression

f = cos(t)
g = sin(t)
h = exp(2*x)

% We can manipulate these functions

simplify(f^2+g^2)
diff(h)

% We can plot a function defined symbolically using the command |ezplot|.
% Learn about the command |ezplot|:

help ezplot

% Plot the function |f(t)| and |h(x)|

ezplot(f)
ezplot(h)
%% 
% If we try to evaluate the function |f(0)|, we get an error message. 
% 
% The symbolic variables are not meant to be used to evaluate functions, but 
% to manipulate functions, compute derivatives, etc. To evaluate a function using 
% symbolic variables is a little cumbersome:

% We need to substitute the variable by a value:

subs(f,t,pi)
%% 
% This expression means: In the expression |f|, substitute the variable |t| 
% by the number |pi|.

% If we use a value where the cosine does not have a "nice" expression, we
% need to approximate the result:

subs(f,t,2)

% We need to use the command |eval|

eval(subs(f,t,2))
%% Exercise 7
% Objective: Define a function using symbolic variables and manipulate it.
% 
% Details: Define the function |f(x) = sin(x)cos(x)|
% 
% Use MATLAB commands to obtain a simpler form of this function, compute value 
% of this function for |x=pi/4| and |x=1|, and plot its graph.
%% Obtaining Picard approximations
% Consider an initial value problem
% 
% |y' = 1 + y| |y(0) = 0|
% 
% First we need to define the variables we will be using

syms t s y;

% We then need to define the function f

f = 1+y; % we define it without the @(t,y) because it is a symbolic function

% We set up our initial approximation phi_0 = 0:

phi=[sym(0)];   % we will keep a list with all the approximations

% Set up a loop to get successive approximations using Picard iterations

N=5;

for i = 1:N
    func=subs(f,y,phi(i));    % prepare function to integrate: y -> previous phi
    func=subs(func,t,s);      % variable of integration is s, so we need to change
                              % t -> s
    
    newphi = int(func, s, 0 ,t);   % integrate to find next approximation
    
    phi=cat(2,phi,[newphi]);       % update the list of approximations by adding new phi
end

% Show the last approximation

phi(N+1)

% Plot the approximation just found

picard=ezplot(phi(N+1),[0,5]);
set(picard,'Color','green');         % set the color of the graph to green

% In this case, the exact solution is
%
% |y=e^t-1|
%
% Compare the approximation and the exact solutions

hold on;
exact=ezplot(exp(t)-1,[0,5]);

xlabel('t');
ylabel('y');
title('Picard Approximations');
legend('Picard Approximation', 'Exact Solution','Location','NorthWest');
%% Exercise 8
%%
% 
%  Objective: Solve your own Picard Approximation and compare it to the
%  exact solution.
%
%%
% 
%  Details: Consider the IVP
%     | y' = 1+y^2|
%     | y(0) = 1 |
%
%% 
% Find the Picard approximation phi_5. For better efficiency, do not keep all 
% the previous approximations.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.
% 
% Label your axes and include a legend.
% 
% HINT. The initial condition has 1 instead of 0, so the Picard method needs 
% to be adapted.
##### SOURCE END #####
--></body></html>